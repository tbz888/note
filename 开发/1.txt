其实现在的异步模型大同小异，大致过程如下（分三层）：
1.（最重要的）维护一个事件反应堆，用epoll或者select或者kqueue来做，反应堆的作用就是用同步的方式处理异步问题，在反应堆上注册好事件后如果相应的事件发生，就调用其回调函数，一般情况下反应堆是一个进程内全局唯一的。
2.上层的buffer，维护一系列的buffer用于管理每一个连接的数据，可以把buffer看做是一个对象。一般在一个连接到达的时候分配一个buffer对象，然后上层的连接注册事件的时候是注册到buffer上，buffer再注册到反应堆中。
3.就是一个个的连接对象，把每一个来自外部的连接都抽象为一个具体的对象，用于管理每一个连接，其中这个对象就包含了上面所说的buffer对象和其他一些状态。

处理并发的过程就是这样的：
1.为监听套接口在反应堆注册一个事件，此事件发生调用对应的回调，一般情况是accept这个连接，然后为这个连接创建连接对象，统一管理。
2.为此连接创建buffer对象，并注册对应的读写错误事件的回调（上层对于buffer的读写事件回调都是业务层来控制的了）.
3.（所谓的排队机制也不是完全正确）在加入监听队列后是离散的，准确来说epoll中是由一颗红黑树维护的，每一个事件的先后顺序跟它达到的顺序有关。
4.维护了众多的连接对象，也就是这里的并发情况了，如果有事件发生会调用回调来处理，理论上无阻塞情况减少了很多CPU的wait，这部分时间用于处理真正的业务，所以异步模型能够带来很高的CPU处理能力，减少等待，单位时间处理的事件越多，从外部来看并发就很高，实际上也是一个串行的工作状态，但是串行过程没有等待。